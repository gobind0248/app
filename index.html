<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#0f172a">
  <meta charset="UTF-8" />
  <title>G.S. Tutorial ‚Äì Interactive Learning App</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- Same CSS as before - not changing -->
  <style>
    /* KEEP ALL THE SAME CSS STYLES HERE */
    /* ... (All the CSS styles remain exactly the same) ... */
  </style>
</head>
<body>
  <!-- Fixed Header -->
  <div class="fixed-header" style="display: none;">
    <div class="header-content">
      <div class="header-left">
        <img src="logo.png" alt="Logo" class="logo-header">
        <div class="header-title-container">
          <div class="header-title">G.S. Tutorial ‚Äì Interactive Learning App</div>
          <div class="header-subtitle">Created by Gobind Sharma</div>
        </div>
      </div>
      <div class="header-right">
        <div class="user-info" id="header-user-info" style="display: none;">
          üë§ <span id="header-username">Guest</span>
        </div>
        <button class="logout-btn" id="header-logout-btn" style="display: none;">
          ‚èª Logout
        </button>
      </div>
    </div>
  </div>
  
  <!-- Main Content Area -->
  <div class="main-content">
    <!-- Login Container -->
    <div id="login-container">
      <div class="login-box">
        <div class="login-header">
          <img src="logo.png" alt="G. S. Tutorial Logo" class="logo-login">
          <div class="login-title">üîê G. S. Tutorial Login</div>
          <div class="login-subtitle">Created by Gobind Sharma</div>
        </div>
        
        <form id="login-form" class="login-form">
          <div class="form-group">
            <label for="username">üë§ Username</label>
            <input type="text" id="username" class="form-input" placeholder="Enter your username" required autocomplete="username">
          </div>
          
          <div class="form-group">
            <label for="password">üîí Password</label>
            <div class="password-input-wrapper">
              <input type="password" id="password" class="form-input" placeholder="Enter your password" required autocomplete="current-password">
              <button type="button" class="password-toggle" id="password-toggle" aria-label="Show password">
                üëÅÔ∏è
              </button>
            </div>
            <div id="attempt-counter" class="attempt-counter" style="display: none;">
              üîÑ Attempts remaining: <span id="attempts-remaining">3</span>
            </div>
            <div id="cooldown-message" class="cooldown-message" style="display: none;">
              ‚è≥ Too many failed attempts. Please wait <span id="cooldown-timer">30</span> seconds.
            </div>
          </div>
          
          <div id="login-error" class="login-error"></div>
          
          <button type="submit" class="login-btn" id="login-btn">
            üîí Login
          </button>
        </form>
        
        <div class="config-info">
          üí° ¬© 2025 G.S. Tutorial. All rights reserved.
        </div>
      </div>
    </div>
    
    <!-- Class Selection Screen -->
    <div class="class-selection" id="class-selection">
      <div class="screen-header">
        <div class="screen-title">Select Your Class</div>
        <div class="screen-subtitle">Choose your class and Start</div>
      </div>
      
      <div class="class-grid" id="class-grid">
        <!-- Classes will be loaded dynamically -->
      </div>
    </div>
    
    <!-- Subject Selection Screen -->
    <div class="subject-selection" id="subject-selection">
      <div class="screen-header">
        <div class="screen-title">Select Subject</div>
        <div class="screen-subtitle" id="current-class-display">Class 8</div>
      </div>
      
      <div class="subject-grid" id="subject-grid">
        <!-- Subjects will be loaded dynamically -->
      </div>
      
      <button class="back-btn" id="back-to-classes-btn">
        ‚Üê Back to Classes
      </button>
    </div>
    
    <!-- Quiz Container -->
    <div class="quiz-container" id="quiz-container">
      <!-- Path Display -->
      <div id="current-path" class="current-path" style="display: none;"></div>
      
      <!-- Topic Selection -->
      <div class="topic-section">
        <div class="topic-info">
          <div class="topic-name" id="quiz-topic-name">No chapter selected</div>
          <div class="question-count" id="quiz-question-count">0 questions</div>
        </div>
        
        <div class="topic-row">
          <select id="topic-select" class="topic-select">
            <option value="">Loading chapters...</option>
          </select>
          <button class="start-btn" id="start-btn" disabled>Start</button>
        </div>
      </div>

      <!-- Timer Container -->
      <div id="timer-container" class="timer-container" style="display: none;">
        <div class="timer-label">‚è∞ Time Remaining:</div>
        <div id="timer-display" class="timer-display">--:--:--</div>
      </div>

      <!-- Randomize Toggle -->
      <div class="toggle-row">
        <input type="checkbox" id="random-toggle" checked />
        <label for="random-toggle">Randomize questions & options</label>
      </div>

      <div class="progress">
        <div id="question-counter">Choose a chapter and click Start</div>
        <div class="progress-bar">
          <div id="progress-bar-fill" class="progress-bar-fill"></div>
        </div>
        <div id="score-mini">Score: 0</div>
      </div>

      <div class="question-box">
        <div id="question-text" class="question-text">
          Please select a chapter to start.
        </div>
        <ul id="options-list" class="options"></ul>
        <div id="feedback" class="feedback"></div>
      </div>

      <!-- Controls -->
      <div class="controls">
        <div class="left-controls">
          <button id="previous-btn" disabled>‚Üê Previous</button>
          <button id="next-btn" disabled>Next ‚Üí</button>
        </div>
        <div class="right-controls">
          <button id="finish-btn" disabled>Finish</button>
        </div>
      </div>

      <div class="score-box">
        <div id="final-score" class="final-score" style="display:none;"></div>
      </div>
    </div>
  </div>

  <script>
    // ========== CONFIGURATION ==========
    let GOOGLE_SHEETS_CONFIG = {
        DEFAULT_SHEET_ID: '1G6tTHT56T6FmqOwOvVFVPoVqoSs-TSBz_-SiW9imQvk',
        DEFAULT_GID: '0'
    };
    
    let TELEGRAM_CONFIG = {
        ENABLED: false,
        BOT_TOKEN: '',
        CHAT_ID: ''
    };
    
    let ADMIN_CONFIG = {
        NOTIFY_ON_LOGIN: false,
        NOTIFY_ON_QUIZ_RESULT: false
    };
    
    let CLASSES_CONFIG = [];

    // ========== GLOBAL VARIABLES ==========
    let questions = [];
    let currentIndex = 0;
    let score = 0;
    let hasAnswered = false;
    let questionsLoaded = false;
    let attempted = 0;
    let userAnswers = [];
    let timeRemaining = 0;
    let timerInterval = null;
    let currentTopicName = "";
    let timerDuration = 0;
    let quizStartTime = null;
    let timerNotification = null;
    let isReviewMode = false;
    let currentSheetConfig = null;
    
    let currentUser = null;
    let userList = [];
    let inactivityTimer = null;
    const INACTIVITY_TIMEOUT = 15 * 60 * 1000;
    
    let failedAttempts = 0;
    const MAX_ATTEMPTS = 3;
    const COOLDOWN_TIME = 30;
    let isOnCooldown = false;
    let cooldownTimer = null;
    
    let currentClass = "";
    let currentSubject = "";
    let chaptersList = [];
    
    let userIP = 'Unknown';
    let currentQuizStats = null;

    // ========== DOM ELEMENTS ==========
    const fixedHeaderEl = document.querySelector(".fixed-header");
    const headerUserInfoEl = document.getElementById("header-user-info");
    const headerUsernameEl = document.getElementById("header-username");
    const headerLogoutBtnEl = document.getElementById("header-logout-btn");
    
    const loginContainerEl = document.getElementById("login-container");
    const classSelectionEl = document.getElementById("class-selection");
    const subjectSelectionEl = document.getElementById("subject-selection");
    const quizContainerEl = document.getElementById("quiz-container");
    
    const loginFormEl = document.getElementById("login-form");
    const usernameEl = document.getElementById("username");
    const passwordEl = document.getElementById("password");
    const passwordToggleEl = document.getElementById("password-toggle");
    const loginErrorEl = document.getElementById("login-error");
    const loginBtnEl = document.getElementById("login-btn");
    const attemptCounterEl = document.getElementById("attempt-counter");
    const attemptsRemainingEl = document.getElementById("attempts-remaining");
    const cooldownMessageEl = document.getElementById("cooldown-message");
    const cooldownTimerEl = document.getElementById("cooldown-timer");
    
    const classGridEl = document.getElementById("class-grid");
    const subjectGridEl = document.getElementById("subject-grid");
    const currentClassDisplayEl = document.getElementById("current-class-display");
    const backToClassesBtn = document.getElementById("back-to-classes-btn");
    const currentPathEl = document.getElementById("current-path");
    
    const topicSelectEl = document.getElementById("topic-select");
    const startBtnEl = document.getElementById("start-btn");
    const randomToggleEl = document.getElementById("random-toggle");
    const quizTopicNameEl = document.getElementById("quiz-topic-name");
    const quizQuestionCountEl = document.getElementById("quiz-question-count");
    const timerContainerEl = document.getElementById("timer-container");
    const timerDisplayEl = document.getElementById("timer-display");
    
    const questionTextEl = document.getElementById("question-text");
    const optionsListEl = document.getElementById("options-list");
    const feedbackEl = document.getElementById("feedback");
    const nextBtn = document.getElementById("next-btn");
    const previousBtn = document.getElementById("previous-btn");
    const finishBtn = document.getElementById("finish-btn");
    const questionCounterEl = document.getElementById("question-counter");
    const progressBarFillEl = document.getElementById("progress-bar-fill");
    const scoreMiniEl = document.getElementById("score-mini");
    const finalScoreEl = document.getElementById("final-score");

    // ========== INITIALIZATION ==========
    async function loadConfigurations() {
        try {
            const configResponse = await fetch('config.js');
            const configText = await configResponse.text();
            
            // Extract Google Sheets config
            const defaultSheetMatch = configText.match(/DEFAULT_SHEET_ID:\s*'([^']+)'/);
            const defaultGidMatch = configText.match(/DEFAULT_GID:\s*'([^']+)'/);
            
            if (defaultSheetMatch && defaultGidMatch) {
                GOOGLE_SHEETS_CONFIG.DEFAULT_SHEET_ID = defaultSheetMatch[1];
                GOOGLE_SHEETS_CONFIG.DEFAULT_GID = defaultGidMatch[1];
                console.log("‚úÖ Loaded Google Sheets config");
            }
            
            // Extract Telegram config
            const telegramEnabledMatch = configText.match(/ENABLED:\s*(true|false)/);
            const botTokenMatch = configText.match(/BOT_TOKEN:\s*'([^']+)'/);
            const chatIdMatch = configText.match(/CHAT_ID:\s*'([^']+)'/);
            
            if (telegramEnabledMatch && botTokenMatch && chatIdMatch) {
                TELEGRAM_CONFIG.ENABLED = telegramEnabledMatch[1] === 'true';
                TELEGRAM_CONFIG.BOT_TOKEN = botTokenMatch[1];
                TELEGRAM_CONFIG.CHAT_ID = chatIdMatch[1];
                console.log("‚úÖ Telegram:", TELEGRAM_CONFIG.ENABLED ? "Enabled" : "Disabled");
            }
            
            // Extract Admin config
            const adminLoginMatch = configText.match(/NOTIFY_ON_LOGIN:\s*(true|false)/);
            const adminQuizMatch = configText.match(/NOTIFY_ON_QUIZ_RESULT:\s*(true|false)/);
            
            if (adminLoginMatch && adminQuizMatch) {
                ADMIN_CONFIG.NOTIFY_ON_LOGIN = adminLoginMatch[1] === 'true';
                ADMIN_CONFIG.NOTIFY_ON_QUIZ_RESULT = adminQuizMatch[1] === 'true';
                console.log("‚úÖ Admin notifications - Login:", ADMIN_CONFIG.NOTIFY_ON_LOGIN, "Quiz:", ADMIN_CONFIG.NOTIFY_ON_QUIZ_RESULT);
            }
            
        } catch (error) {
            console.error("‚ùå Error loading configuration:", error);
        }
        
        await loadClassesConfig();
        await getUserIP();
    }

    async function loadClassesConfig() {
        try {
            const response = await fetch('classes.json');
            CLASSES_CONFIG = await response.json();
            console.log(`‚úÖ Loaded ${CLASSES_CONFIG.length} classes:`, CLASSES_CONFIG.map(c => c.name));
        } catch (error) {
            console.error("‚ùå Error loading classes.json:", error);
            CLASSES_CONFIG = [];
        }
    }

    async function getUserIP() {
        try {
            const response = await fetch('https://api.ipify.org?format=json');
            const data = await response.json();
            userIP = data.ip;
            console.log("üåê User IP:", userIP);
        } catch (error) {
            console.log("‚ö†Ô∏è Could not fetch IP");
        }
    }

    // ========== LOGIN SYSTEM ==========
    async function loadUsersFromGoogleSheet() {
        try {
            console.log("üì• Loading users from Google Sheet...");
            
            const apiUrl = `https://docs.google.com/spreadsheets/d/${GOOGLE_SHEETS_CONFIG.DEFAULT_SHEET_ID}/gviz/tq?tqx=out:json&gid=${GOOGLE_SHEETS_CONFIG.DEFAULT_GID}`;
            console.log("üîó Fetching from:", apiUrl);
            
            const response = await fetch(apiUrl);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            
            const data = await response.text();
            const jsonStart = data.indexOf('{');
            const jsonEnd = data.lastIndexOf('}') + 1;
            const jsonStr = data.substring(jsonStart, jsonEnd);
            const jsonData = JSON.parse(jsonStr);
            
            const rows = jsonData.table.rows;
            userList = [];
            
            console.log(`üìä Total rows: ${rows.length}`);
            
            // Start from row 1 (skip headers)
            for (let i = 1; i < rows.length; i++) {
                const row = rows[i];
                
                if (row.c && row.c.length >= 2) {
                    const username = row.c[0] ? row.c[0].v.toString().trim() : '';
                    const password = row.c[1] ? row.c[1].v.toString().trim() : '';
                    const name = row.c[2] ? row.c[2].v.toString().trim() : username;
                    const role = row.c[3] ? row.c[3].v.toString().trim() : 'Student';
                    const userClass = row.c[4] ? row.c[4].v.toString().trim() : '';
                    
                    if (username && password) {
                        userList.push({
                            username,
                            password,
                            name,
                            role: role || 'Student',
                            class: userClass || ''
                        });
                        console.log(`üë§ Loaded: ${username} (${role}, Class: ${userClass})`);
                    }
                }
            }
            
            console.log(`‚úÖ Loaded ${userList.length} users`);
            return userList.length > 0;
            
        } catch (error) {
            console.error("‚ùå Error loading users:", error);
            loginErrorEl.textContent = "‚ö†Ô∏è Cannot connect to login database";
            loginErrorEl.style.display = "block";
            userList = [];
            return false;
        }
    }

    function authenticateUser(username, password) {
        return userList.find(u => 
            u.username.toLowerCase() === username.toLowerCase() && 
            u.password === password
        );
    }

    function login(user) {
        currentUser = user;
        headerUsernameEl.textContent = user.name;
        
        fixedHeaderEl.style.display = "block";
        headerUserInfoEl.style.display = "block";
        headerLogoutBtnEl.style.display = "block";
        loginContainerEl.style.display = "none";
        classSelectionEl.style.display = "block";
        
        resetFailedAttempts();
        resetInactivityTimer();
        loadClasses();
        sendLoginNotification(user);
        
        console.log(`üéâ User ${user.name} logged in. Role: ${user.role}, Class: "${user.class}"`);
    }

    function logout() {
        if (confirm("Are you sure you want to logout?")) {
            if (timerInterval) clearInterval(timerInterval);
            if (inactivityTimer) clearTimeout(inactivityTimer);
            if (cooldownTimer) clearInterval(cooldownTimer);
            
            document.removeEventListener('mousemove', resetInactivityTimer);
            document.removeEventListener('keypress', resetInactivityTimer);
            document.removeEventListener('click', resetInactivityTimer);
            
            resetQuizState();
            resetFailedAttempts();
            currentUser = null;
            
            fixedHeaderEl.style.display = "none";
            classSelectionEl.style.display = "none";
            subjectSelectionEl.style.display = "none";
            quizContainerEl.style.display = "none";
            loginContainerEl.style.display = "flex";
            
            loginFormEl.reset();
            passwordEl.type = 'password';
            passwordToggleEl.textContent = 'üëÅÔ∏è';
            loginErrorEl.textContent = "";
            loginErrorEl.style.display = "none";
            usernameEl.focus();
            
            console.log("üëã User logged out");
        }
    }

    function togglePasswordVisibility() {
        if (passwordEl.type === 'password') {
            passwordEl.type = 'text';
            passwordToggleEl.textContent = 'üôà';
        } else {
            passwordEl.type = 'password';
            passwordToggleEl.textContent = 'üëÅÔ∏è';
        }
        resetInactivityTimer();
    }

    function resetFailedAttempts() {
        failedAttempts = 0;
        isOnCooldown = false;
        attemptCounterEl.style.display = 'none';
        cooldownMessageEl.style.display = 'none';
        updateAttemptCounter();
        if (cooldownTimer) {
            clearInterval(cooldownTimer);
            cooldownTimer = null;
        }
    }

    function updateAttemptCounter() {
        const remaining = MAX_ATTEMPTS - failedAttempts;
        attemptsRemainingEl.textContent = remaining;
        
        if (failedAttempts > 0) {
            attemptCounterEl.style.display = 'flex';
            if (remaining <= 1) attemptCounterEl.className = 'attempt-counter critical';
            else if (remaining <= 2) attemptCounterEl.className = 'attempt-counter warning';
        } else {
            attemptCounterEl.style.display = 'none';
        }
    }

    function startCooldown() {
        isOnCooldown = true;
        loginBtnEl.disabled = true;
        cooldownMessageEl.style.display = 'block';
        attemptCounterEl.style.display = 'none';
        
        let seconds = COOLDOWN_TIME;
        cooldownTimerEl.textContent = seconds;
        
        cooldownTimer = setInterval(() => {
            seconds--;
            cooldownTimerEl.textContent = seconds;
            
            if (seconds <= 0) {
                clearInterval(cooldownTimer);
                isOnCooldown = false;
                loginBtnEl.disabled = false;
                cooldownMessageEl.style.display = 'none';
                resetFailedAttempts();
                usernameEl.focus();
            }
        }, 1000);
    }

    function recordFailedAttempt() {
        failedAttempts++;
        updateAttemptCounter();
        
        if (failedAttempts >= MAX_ATTEMPTS) {
            startCooldown();
        }
    }

    function autoLogout() {
        if (currentUser) {
            alert("You have been automatically logged out due to inactivity (15 minutes).");
            logout();
        }
    }

    function resetInactivityTimer() {
        if (inactivityTimer) clearTimeout(inactivityTimer);
        inactivityTimer = setTimeout(autoLogout, INACTIVITY_TIMEOUT);
    }

    // ========== NOTIFICATION SYSTEM ==========
    async function sendLoginNotification(user) {
        if (!TELEGRAM_CONFIG.ENABLED) return;
        if (user.role === 'Admin' && !ADMIN_CONFIG.NOTIFY_ON_LOGIN) {
            console.log("‚ÑπÔ∏è Skipping login notification for admin");
            return;
        }
        
        const now = new Date();
        const date = now.toLocaleDateString('en-IN');
        const time = now.toLocaleTimeString('en-IN');
        
        const message = `üîî *New User Login*\nüë§ Username: ${user.username}\nüéì Name: ${user.name}\nüè´ Class: ${user.class || 'Not assigned'}\nüë• Role: ${user.role}\nüìÖ Date: ${date}\n‚è∞ Time: ${time}\nüåê IP: ${userIP}`;
        
        console.log("üì± Sending login notification");
        await sendTelegramMessage(message);
    }

    async function sendQuizResultNotification(stats) {
        if (!TELEGRAM_CONFIG.ENABLED) return;
        if (currentUser.role === 'Admin' && !ADMIN_CONFIG.NOTIFY_ON_QUIZ_RESULT) {
            console.log("‚ÑπÔ∏è Skipping quiz notification for admin");
            return;
        }
        
        if (!currentUser || !currentQuizStats) return;
        
        const now = new Date();
        const date = now.toLocaleDateString('en-IN');
        
        const message = `üìä *Quiz Result*\nüë§ Username: ${currentUser.username}\nüéì Name: ${currentUser.name}\nüè´ Class: ${currentClass}\nüìö Subject: ${currentSubject}\nüìñ Chapter: ${currentTopicName}\n‚úÖ Correct: ${stats.correct}\nüìã Total: ${stats.total}\nüìà Score: ${stats.percentage}%\n‚è±Ô∏è Time: ${stats.timeTaken || "N/A"}\nüìÖ Date: ${date}`;
        
        console.log("üìä Sending quiz result notification");
        await sendTelegramMessage(message);
    }

    async function sendTelegramMessage(message) {
        try {
            if (!TELEGRAM_CONFIG.BOT_TOKEN || !TELEGRAM_CONFIG.CHAT_ID) {
                console.error("‚ùå Telegram not configured");
                return;
            }
            
            const url = `https://api.telegram.org/bot${TELEGRAM_CONFIG.BOT_TOKEN}/sendMessage`;
            
            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    chat_id: TELEGRAM_CONFIG.CHAT_ID,
                    text: message,
                    parse_mode: 'Markdown'
                })
            });
            
            if (response.ok) {
                console.log("‚úÖ Telegram notification sent");
            } else {
                console.error("‚ùå Telegram API error");
            }
        } catch (error) {
            console.error("‚ùå Error sending Telegram:", error);
        }
    }

    // ========== NAVIGATION - FIXED ==========
    function showClassSelection() {
        classSelectionEl.style.display = "block";
        subjectSelectionEl.style.display = "none";
        quizContainerEl.style.display = "none";
        resetQuizState();
        isReviewMode = false;
    }

    function showSubjectSelection(className) {
        currentClass = className;
        currentClassDisplayEl.textContent = `Class ${className}`;
        
        classSelectionEl.style.display = "none";
        subjectSelectionEl.style.display = "block";
        quizContainerEl.style.display = "none";
        
        loadSubjects();
        isReviewMode = false;
    }

    function showQuizContainer(subjectName) {
        currentSubject = subjectName;
        
        currentPathEl.innerHTML = `
            <span class="path-link" onclick="showClassSelection()">Classes</span>
            <span class="path-separator">‚Ä∫</span>
            <span class="path-link" onclick="showSubjectSelection('${currentClass}')">Class ${currentClass}</span>
            <span class="path-separator">‚Ä∫</span>
            <span>${subjectName}</span>
        `;
        currentPathEl.style.display = "flex";
        
        subjectSelectionEl.style.display = "none";
        quizContainerEl.style.display = "block";
        
        loadChapters();
        isReviewMode = false;
    }

    // ========== FIXED: LOAD CLASSES FUNCTION ==========
    function loadClasses() {
        const userClassValue = currentUser?.class || "";
        let availableClasses = [];

        console.log(`üë§ User Role: ${currentUser.role}, Class from sheet: "${userClassValue}"`);
        console.log(`üìö Total classes in config: ${CLASSES_CONFIG.length}`);

        // ADMIN - ALL CLASSES
        if (currentUser.role === 'Admin') {
            availableClasses = CLASSES_CONFIG;
            console.log("üëë Admin: Showing ALL classes");
        }
        // TEACHER - ASSIGNED CLASSES
        else if (currentUser.role === 'Teacher') {
            if (!userClassValue || userClassValue.toLowerCase() === "all") {
                availableClasses = CLASSES_CONFIG;
                console.log("üë®‚Äçüè´ Teacher: Showing ALL classes (assigned: all)");
            } else {
                // Split by comma and clean up
                const teacherClasses = userClassValue.split(',')
                    .map(c => c.trim())
                    .map(c => c.replace(/class/i, '').trim());
                
                console.log("Teacher classes after cleaning:", teacherClasses);
                
                availableClasses = CLASSES_CONFIG.filter(cls => 
                    teacherClasses.includes(cls.id)
                );
                console.log(`üë®‚Äçüè´ Teacher: Showing classes for IDs: ${teacherClasses.join(', ')}`);
            }
        }
        // STUDENT - ONLY THEIR CLASS
        else {
            let studentClass = userClassValue || "";
            
            // Extract numbers from class string (e.g., "Class 8" -> "8", "8" -> "8")
            const match = studentClass.match(/\d+/);
            studentClass = match ? match[0] : studentClass;
            
            if (!studentClass) studentClass = "8";
            
            console.log(`üéì Student class extracted: ${studentClass}`);
            
            const cls = CLASSES_CONFIG.find(c => c.id === studentClass);
            
            if (cls) {
                availableClasses = [cls];
                console.log(`üéì Student: Showing class ${studentClass} only`);
            } else {
                console.error(`‚ùå Class ${studentClass} not found in config`);
                availableClasses = [];
            }
        }

        // RENDER CLASSES
        classGridEl.innerHTML = "";

        if (availableClasses.length === 0) {
            classGridEl.innerHTML = '<div style="text-align: center; color: #ef4444; padding: 20px;">No classes available for your account.</div>';
            return;
        }

        console.log(`üìö Rendering ${availableClasses.length} classes:`);
        availableClasses.forEach(cls => {
            console.log(`  - ${cls.name} (ID: ${cls.id})`);
            
            const card = document.createElement("div");
            card.className = "class-card";
            card.innerHTML = `
                <div class="class-icon">${cls.icon}</div>
                <div class="class-name">${cls.name}</div>
                <div class="class-desc">${cls.description || ""}</div>
            `;

            card.addEventListener("click", () => {
                showSubjectSelection(cls.id);
                resetInactivityTimer();
            });

            classGridEl.appendChild(card);
        });

        console.log(`‚úÖ Showing ${availableClasses.length} classes`);
    }

    function loadSubjects() {
        const currentClassConfig = CLASSES_CONFIG.find(cls => cls.id === currentClass);
        
        if (!currentClassConfig || !currentClassConfig.subjects) {
            subjectGridEl.innerHTML = '<div style="text-align: center; color: #ef4444; padding: 20px;">No subjects available.</div>';
            return;
        }
        
        subjectGridEl.innerHTML = "";
        
        currentClassConfig.subjects.forEach(subject => {
            const card = document.createElement("div");
            card.className = "subject-card";
            card.innerHTML = `
                <div class="subject-icon">${subject.icon}</div>
                <div class="subject-name">${subject.name}</div>
                <div class="subject-desc">${subject.description}</div>
            `;
            
            card.addEventListener("click", () => {
                currentSubject = subject.name;
                showQuizContainer(currentSubject);
                resetInactivityTimer();
            });
            
            subjectGridEl.appendChild(card);
        });
    }

    // ========== GOOGLE SHEETS INTEGRATION ==========
    async function loadSheetConfig(className) {
        try {
            const classConfig = CLASSES_CONFIG.find(cls => cls.id === className);
            if (!classConfig || !classConfig.googleSheets || !classConfig.googleSheets.enabled) {
                console.error(`‚ùå Google Sheets not configured for ${className}`);
                return null;
            }

            console.log(`üì• Loading sheet config: ${classConfig.googleSheets.configFile}`);
            const response = await fetch(classConfig.googleSheets.configFile);
            
            if (!response.ok) {
                throw new Error(`Failed to load config: ${response.status}`);
            }
            
            currentSheetConfig = await response.json();
            console.log(`‚úÖ Loaded config for ${className}`);
            return currentSheetConfig;
        } catch (error) {
            console.error(`‚ùå Error loading sheet config:`, error);
            return null;
        }
    }

    async function loadChapters() {
        try {
            console.log(`üìñ Loading chapters for ${currentClass} - ${currentSubject}`);
            
            const sheetConfig = await loadSheetConfig(currentClass);
            
            if (!sheetConfig) {
                showChapterError(`Google Sheets not configured for Class ${currentClass}`);
                return;
            }
            
            const subjectKey = currentSubject.toLowerCase();
            if (!sheetConfig[subjectKey]) {
                showChapterError(`Subject "${currentSubject}" not configured`);
                return;
            }
            
            const subjectConfig = sheetConfig[subjectKey];
            chaptersList = Object.keys(subjectConfig.chapters || {});
            
            if (chaptersList.length === 0) {
                showChapterError("No chapters configured");
                return;
            }
            
            populateChapterDropdown();
            console.log(`‚úÖ Loaded ${chaptersList.length} chapters`);
            
        } catch (err) {
            console.error("‚ùå Error loading chapters:", err);
            showChapterError(err.message);
        }
        
        resetInactivityTimer();
    }

    function populateChapterDropdown() {
        topicSelectEl.innerHTML = '<option value="">-- Select Chapter --</option>';
        
        chaptersList.forEach(chapter => {
            if (chapter && chapter.trim()) {
                const option = document.createElement("option");
                option.value = chapter.trim();
                option.textContent = chapter.trim();
                topicSelectEl.appendChild(option);
            }
        });
        
        startBtnEl.disabled = false;
        quizTopicNameEl.textContent = "No chapter selected";
        quizQuestionCountEl.textContent = `${chaptersList.length} chapters available`;
        questionTextEl.textContent = "Select a chapter to start.";
    }

    function showChapterError(errorMessage) {
        topicSelectEl.innerHTML = `
            <option value="">-- Error --</option>
            <option value="">${errorMessage}</option>
        `;
        
        quizTopicNameEl.textContent = "Error";
        quizTopicNameEl.style.backgroundColor = "rgba(239, 68, 68, 0.1)";
        quizTopicNameEl.style.borderColor = "rgba(239, 68, 68, 0.5)";
        quizTopicNameEl.style.color = "#fca5a5";
        quizQuestionCountEl.textContent = "0 chapters";
        questionTextEl.textContent = errorMessage;
        startBtnEl.disabled = true;
    }

    async function loadQuestionsFromGoogleSheet(subjectName, chapterName) {
        console.log(`üì• Loading: ${subjectName} - ${chapterName}`);
        
        if (!currentSheetConfig) {
            showChapterError("Google Sheets config not loaded");
            return;
        }

        const subjectKey = subjectName.toLowerCase();
        if (!currentSheetConfig[subjectKey]) {
            showChapterError(`Subject "${subjectName}" not configured`);
            return;
        }

        const subjectConfig = currentSheetConfig[subjectKey];
        const gid = subjectConfig.chapters[chapterName];

        if (!gid) {
            showChapterError(`Chapter "${chapterName}" not found`);
            return;
        }

        const sheetId = subjectConfig.sheetId;
        if (!sheetId || sheetId === 'YOUR_SHEET_ID_HERE') {
            showChapterError("Sheet ID not configured. Update config file.");
            return;
        }

        const apiUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:json&gid=${gid}`;
        console.log("üîó Fetching from:", apiUrl);

        try {
            questionTextEl.textContent = `Loading ${chapterName}...`;
            startBtnEl.disabled = true;
            
            const response = await fetch(apiUrl);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            
            const data = await response.text();
            const jsonStart = data.indexOf('{');
            const jsonEnd = data.lastIndexOf('}') + 1;
            const jsonStr = data.substring(jsonStart, jsonEnd);
            const jsonData = JSON.parse(jsonStr);
            
            const rows = jsonData.table.rows;
            console.log(`üìä Received ${rows.length} rows`);
            
            if (rows.length < 2) {
                throw new Error("Sheet is empty");
            }
            
            // Parse questions
            questions = [];
            let sheetTimer = 0;
            
            // Get timer from row 1, column H
            if (rows[1].c && rows[1].c[7]) {
                sheetTimer = parseInt(rows[1].c[7].v) || 0;
                console.log(`‚è∞ Timer: ${sheetTimer} minutes`);
            }
            
            // Parse questions from row 2 onwards
            for (let i = 2; i < rows.length; i++) {
                const row = rows[i];
                
                if (!row.c || row.c.length < 2) continue;
                
                const question = row.c[0] ? row.c[0].v.toString().trim() : '';
                const optionA = row.c[1] ? row.c[1].v.toString().trim() : '';
                const optionB = row.c[2] ? row.c[2].v.toString().trim() : '';
                const optionC = row.c[3] ? row.c[3].v.toString().trim() : '';
                const optionD = row.c[4] ? row.c[4].v.toString().trim() : '';
                const answer = row.c[5] ? row.c[5].v.toString().trim() : '';
                const explanation = row.c[6] ? row.c[6].v.toString().trim() : '';
                
                if (!question || !optionA || !optionB || !answer) continue;
                
                const options = [optionA, optionB];
                if (optionC) options.push(optionC);
                if (optionD) options.push(optionD);
                
                // Determine correct index
                let correctIndex = -1;
                const answerUpper = answer.toUpperCase().trim();
                
                if (answerUpper === 'A') correctIndex = 0;
                else if (answerUpper === 'B') correctIndex = 1;
                else if (answerUpper === 'C') correctIndex = 2;
                else if (answerUpper === 'D') correctIndex = 3;
                
                // Try number (1, 2, 3, 4)
                if (correctIndex === -1) {
                    const answerNum = parseInt(answer);
                    if (!isNaN(answerNum) && answerNum >= 1 && answerNum <= options.length) {
                        correctIndex = answerNum - 1;
                    }
                }
                
                // Try text match
                if (correctIndex === -1) {
                    const answerLower = answer.toLowerCase().trim();
                    for (let j = 0; j < options.length; j++) {
                        if (options[j].toLowerCase() === answerLower) {
                            correctIndex = j;
                            break;
                        }
                    }
                }
                
                if (correctIndex === -1) continue;
                
                questions.push({
                    question,
                    options,
                    correctIndex,
                    explanation: explanation || ''
                });
            }
            
            if (questions.length === 0) {
                throw new Error("No valid questions found");
            }
            
            timerDuration = sheetTimer * 60 * 1000;
            
            // Apply randomization
            const randomize = randomToggleEl.checked;
            if (randomize) {
                shuffleArray(questions);
                questions.forEach(q => {
                    const idxs = q.options.map((_, idx) => idx);
                    shuffleArray(idxs);
                    const newOptions = idxs.map(i => q.options[i]);
                    const newCorrectIndex = idxs.indexOf(q.correctIndex);
                    q.options = newOptions;
                    q.correctIndex = newCorrectIndex;
                });
            }
            
            userAnswers = new Array(questions.length);
            questionsLoaded = true;
            currentIndex = 0;
            score = 0;
            attempted = 0;
            
            quizTopicNameEl.textContent = chapterName;
            quizQuestionCountEl.textContent = `${questions.length} questions`;
            
            if (timerDuration > 0) {
                showTimerNotification();
                startTimer();
            }
            
            renderQuestion();
            console.log(`‚úÖ Loaded ${questions.length} questions`);
            
        } catch (error) {
            console.error("‚ùå Error loading questions:", error);
            showChapterError(`Failed to load: ${error.message}`);
        }
    }

    // ========== QUIZ FUNCTIONS ==========
    function resetQuizState() {
        questions = [];
        currentIndex = 0;
        score = 0;
        hasAnswered = false;
        questionsLoaded = false;
        attempted = 0;
        userAnswers = [];
        timeRemaining = 0;
        timerDuration = 0;
        currentTopicName = "";
        quizStartTime = null;
        isReviewMode = false;
        
        questionTextEl.textContent = "Please select a chapter to start.";
        optionsListEl.innerHTML = "";
        feedbackEl.textContent = "";
        feedbackEl.className = "feedback";
        nextBtn.disabled = true;
        previousBtn.disabled = true;
        finishBtn.disabled = true;
        finishBtn.textContent = "Finish Quiz";
        finishBtn.onclick = () => {
            if (!questionsLoaded) return;
            if (confirm("Finish the quiz?")) {
                showFinalResult();
            }
            resetInactivityTimer();
        };
        finalScoreEl.style.display = "none";
        progressBarFillEl.style.width = "0%";
        questionCounterEl.textContent = "Choose a chapter and click Start";
        scoreMiniEl.textContent = "Score: 0";
        quizTopicNameEl.textContent = "No chapter selected";
        quizQuestionCountEl.textContent = "0 questions";
        timerContainerEl.style.display = "none";
        
        quizTopicNameEl.style.backgroundColor = "";
        quizTopicNameEl.style.borderColor = "";
        quizTopicNameEl.style.color = "";
        
        removeTimerNotification();
    }

    function shuffleArray(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
    }

    function renderQuestion() {
        if (!questionsLoaded || questions.length === 0) {
            questionTextEl.textContent = "No questions available.";
            optionsListEl.innerHTML = "";
            nextBtn.disabled = true;
            previousBtn.disabled = true;
            finishBtn.disabled = true;
            return;
        }

        const q = questions[currentIndex];
        hasAnswered = false;
        feedbackEl.textContent = "";
        feedbackEl.className = "feedback";
        
        const existingExplanation = feedbackEl.querySelector('.explanation');
        if (existingExplanation) existingExplanation.remove();

        questionCounterEl.textContent = `Question ${currentIndex + 1} / ${questions.length}`;
        const progressPercent = ((currentIndex + 1) / questions.length) * 100;
        progressBarFillEl.style.width = `${progressPercent}%`;

        questionTextEl.textContent = q.question;
        optionsListEl.innerHTML = "";

        q.options.forEach((opt, idx) => {
            const li = document.createElement("li");
            li.className = "option";
            
            if (userAnswers[currentIndex] !== undefined && userAnswers[currentIndex] === idx) {
                li.classList.add("selected");
            }

            const label = document.createElement("div");
            label.textContent = opt;
            li.appendChild(label);
            optionsListEl.appendChild(li);

            li.addEventListener("click", () => {
                if (hasAnswered || isReviewMode) return;
                
                document.querySelectorAll(".option").forEach(opt => {
                    opt.classList.remove("selected");
                });
                
                li.classList.add("selected");
                userAnswers[currentIndex] = idx;
                handleOptionClick(idx);
                resetInactivityTimer();
            });
        });

        previousBtn.disabled = (currentIndex === 0);
        
        if (isReviewMode) {
            nextBtn.disabled = false;
            showQuestionInReviewMode();
        } else {
            nextBtn.disabled = true;
        }
        
        finishBtn.disabled = false;
        
        if (userAnswers[currentIndex] !== undefined) {
            const selectedIndex = userAnswers[currentIndex];
            const isCorrect = (selectedIndex === q.correctIndex);
            
            showCorrectness(selectedIndex);
            lockOptions();
            hasAnswered = true;
            
            if (isCorrect) {
                feedbackEl.textContent = "‚úÖ Correct!";
                feedbackEl.className = "feedback correct";
            } else {
                feedbackEl.textContent = `‚ùå Wrong. Correct: ${q.options[q.correctIndex]}`;
                feedbackEl.className = "feedback incorrect";
            }
            
            if (q.explanation) {
                const explanationDiv = document.createElement("div");
                explanationDiv.className = "explanation";
                explanationDiv.innerHTML = `<strong>Explanation:</strong> ${q.explanation}`;
                feedbackEl.appendChild(explanationDiv);
            }
            
            if (!isReviewMode) {
                nextBtn.disabled = false;
            }
        }
        
        resetInactivityTimer();
    }

    function showQuestionInReviewMode() {
        const q = questions[currentIndex];
        const selectedIndex = userAnswers[currentIndex];
        const hasAnsweredQuestion = selectedIndex !== undefined;
        
        if (hasAnsweredQuestion) {
            const isCorrect = (selectedIndex === q.correctIndex);
            
            showCorrectness(selectedIndex);
            lockOptions();
            hasAnswered = true;
            
            if (isCorrect) {
                feedbackEl.textContent = "‚úÖ Your answer was correct!";
                feedbackEl.className = "feedback correct";
            } else {
                feedbackEl.textContent = `‚ùå Your answer was incorrect. Correct: ${q.options[q.correctIndex]}`;
                feedbackEl.className = "feedback incorrect";
            }
            
            if (q.explanation) {
                const explanationDiv = document.createElement("div");
                explanationDiv.className = "explanation";
                explanationDiv.innerHTML = `<strong>Explanation:</strong> ${q.explanation}`;
                feedbackEl.appendChild(explanationDiv);
            }
        } else {
            feedbackEl.textContent = "‚ö†Ô∏è You did not answer this question.";
            feedbackEl.className = "feedback";
            
            showCorrectness(-1);
            lockOptions();
            
            if (q.explanation) {
                const explanationDiv = document.createElement("div");
                explanationDiv.className = "explanation";
                explanationDiv.innerHTML = `<strong>Correct Answer:</strong> ${q.options[q.correctIndex]}<br><br><strong>Explanation:</strong> ${q.explanation}`;
                feedbackEl.appendChild(explanationDiv);
            }
        }
    }

    function handleOptionClick(selectedIndex) {
        if (hasAnswered || isReviewMode) return;
        
        const q = questions[currentIndex];
        hasAnswered = true;
        attempted++;
        
        const isCorrect = (selectedIndex === q.correctIndex);
        
        if (isCorrect) {
            score++;
            feedbackEl.textContent = "‚úÖ Correct!";
            feedbackEl.className = "feedback correct";
        } else {
            feedbackEl.textContent = `‚ùå Wrong. Correct: ${q.options[q.correctIndex]}`;
            feedbackEl.className = "feedback incorrect";
        }
        
        if (q.explanation) {
            const explanationDiv = document.createElement("div");
            explanationDiv.className = "explanation";
            explanationDiv.innerHTML = `<strong>Explanation:</strong> ${q.explanation}`;
            feedbackEl.appendChild(explanationDiv);
        }
        
        scoreMiniEl.textContent = `Score: ${score}`;
        showCorrectness(selectedIndex);
        lockOptions();
        nextBtn.disabled = false;
    }

    function lockOptions() {
        const optionEls = document.querySelectorAll(".option");
        optionEls.forEach(opt => opt.classList.add("disabled"));
    }

    function showCorrectness(selectedIndex) {
        const q = questions[currentIndex];
        const optionEls = document.querySelectorAll(".option");
        optionEls.forEach((optEl, idx) => {
            optEl.classList.remove("correct", "incorrect");
            if (idx === q.correctIndex) optEl.classList.add("correct");
            if (idx === selectedIndex && selectedIndex !== q.correctIndex) {
                optEl.classList.add("incorrect");
            }
        });
    }

    function goToNextQuestion() {
        currentIndex++;
        if (currentIndex < questions.length) {
            renderQuestion();
        } else {
            if (!isReviewMode) {
                progressBarFillEl.style.width = "100%";
                showFinalResult();
            } else {
                currentIndex = 0;
                renderQuestion();
            }
        }
        resetInactivityTimer();
    }

    function goToPreviousQuestion() {
        if (currentIndex > 0) {
            currentIndex--;
            renderQuestion();
        }
        resetInactivityTimer();
    }

    // ========== TIMER FUNCTIONS ==========
    function startTimer() {
        if (timerDuration <= 0) return;
        
        timeRemaining = timerDuration;
        timerContainerEl.style.display = "flex";
        updateTimerDisplay();
        
        timerInterval = setInterval(() => {
            timeRemaining -= 1000;
            
            if (timeRemaining <= 0) {
                timeRemaining = 0;
                clearInterval(timerInterval);
                autoFinishQuiz();
            }
            
            updateTimerDisplay();
        }, 1000);
    }

    function updateTimerDisplay() {
        const hours = Math.floor(timeRemaining / (1000 * 60 * 60));
        const minutes = Math.floor((timeRemaining % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((timeRemaining % (1000 * 60)) / 1000);
        
        timerDisplayEl.textContent = 
            `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        
        timerDisplayEl.classList.remove("timer-warning", "timer-critical");
        
        if (timeRemaining <= 30 * 60 * 1000) timerDisplayEl.classList.add("timer-warning");
        if (timeRemaining <= 10 * 60 * 1000) timerDisplayEl.classList.add("timer-critical");
    }

    function stopTimer() {
        if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
        }
        timerContainerEl.style.display = "none";
    }

    function showTimerNotification() {
        removeTimerNotification();
        
        if (timerDuration > 0) {
            const minutes = Math.floor(timerDuration / (1000 * 60));
            const timeString = `${minutes} minute${minutes !== 1 ? 's' : ''}`;
            
            timerNotification = document.createElement("div");
            timerNotification.className = "timer-notification";
            timerNotification.innerHTML = `
                <span>‚è∞</span>
                <span>Timer set: <strong>${timeString}</strong></span>
            `;
            
            const toggleRow = document.querySelector(".toggle-row");
            if (toggleRow && toggleRow.nextElementSibling) {
                toggleRow.parentNode.insertBefore(timerNotification, toggleRow.nextElementSibling);
            }
        }
    }

    function removeTimerNotification() {
        if (timerNotification && timerNotification.parentNode) {
            timerNotification.parentNode.removeChild(timerNotification);
            timerNotification = null;
        }
        
        document.querySelectorAll(".timer-notification").forEach(n => {
            if (n.parentNode) n.parentNode.removeChild(n);
        });
    }

    function autoFinishQuiz() {
        showFinalResult();
        stopTimer();
        removeTimerNotification();
    }

    function formatTimeTaken() {
        if (timerDuration <= 0 || !quizStartTime) return "";
        
        const endTime = Date.now();
        const timeTaken = endTime - quizStartTime;
        const minutes = Math.floor(timeTaken / (1000 * 60));
        const seconds = Math.floor((timeTaken % (1000 * 60)) / 1000);
        
        if (minutes > 0) {
            return `${minutes}m ${seconds}s`;
        } else {
            return `${seconds}s`;
        }
    }

    // ========== RESULTS ==========
    function calculateQuizStats() {
        let attempted = 0;
        let correct = 0;
        
        for (let i = 0; i < questions.length; i++) {
            if (userAnswers[i] !== undefined) {
                attempted++;
                if (userAnswers[i] === questions[i].correctIndex) {
                    correct++;
                }
            }
        }
        
        const percentage = questions.length > 0 ? ((correct / questions.length) * 100).toFixed(2) : 0;
        
        return {
            total: questions.length,
            attempted,
            correct,
            percentage
        };
    }

    function showFinalResult() {
        stopTimer();
        removeTimerNotification();
        
        const stats = calculateQuizStats();
        const timeTaken = formatTimeTaken();
        quizStartTime = Date.now();
        
        currentQuizStats = {
            ...stats,
            timeTaken: timeTaken,
            subject: currentSubject,
            chapter: currentTopicName,
            class: currentClass
        };
        
        progressBarFillEl.style.width = "100%";
        questionTextEl.textContent = "Quiz Completed!";
        optionsListEl.innerHTML = "";
        feedbackEl.textContent = "";
        nextBtn.style.display = "none";
        previousBtn.style.display = "none";
        finishBtn.style.display = "none";
        finalScoreEl.style.display = "block";
        
        let performanceMessage = "";
        if (stats.percentage >= 80) performanceMessage = "üéâ Excellent!";
        else if (stats.percentage >= 60) performanceMessage = "üëç Good job!";
        else if (stats.percentage >= 40) performanceMessage = "üìö Keep learning!";
        else performanceMessage = "üìñ Needs improvement.";
        
        sendQuizResultNotification(currentQuizStats);
        
        let reviewSection = '';
        if (questions.length > 0) {
            reviewSection = `
                <div class="result-summary" style="margin-top: 20px;">
                    <button class="review-btn" onclick="showQuestionReview()">
                        üìñ Review Questions
                    </button>
                </div>
            `;
        }
        
        finalScoreEl.innerHTML = `
            <div class="result-header">Results - ${currentTopicName}</div>
            <div class="result-stats">
                <div class="stat-item">
                    <div class="stat-label">Total Questions</div>
                    <div class="stat-value">${stats.total}</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Attempted</div>
                    <div class="stat-value">${stats.attempted}/${stats.total}</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Correct Answers</div>
                    <div class="stat-value">${stats.correct}</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Score</div>
                    <div class="stat-value stat-percentage">${stats.percentage}%</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Time Taken</div>
                    <div class="stat-value stat-time">${timeTaken || "No timer"}</div>
                </div>
                ${timerDuration > 0 ? `
                <div class="stat-item">
                    <div class="stat-label">Time Limit</div>
                    <div class="stat-value">${Math.floor(timerDuration / (1000 * 60))} minutes</div>
                </div>
                ` : ''}
            </div>
            <div class="result-message">
                ${performanceMessage}
            </div>
            <div class="result-summary">
                <em>Select another chapter to start a new quiz.</em>
            </div>
            <button class="restart-btn" onclick="restartQuiz()">Restart</button>
            ${reviewSection}
        `;
        
        resetInactivityTimer();
    }

    function showQuestionReview() {
        isReviewMode = true;
        finalScoreEl.style.display = "none";
        nextBtn.style.display = "inline-block";
        previousBtn.style.display = "inline-block";
        finishBtn.style.display = "inline-block";
        finishBtn.textContent = "Back to Results";
        finishBtn.onclick = () => {
            showFinalResult();
        };
        
        currentIndex = 0;
        renderQuestion();
    }

    function restartQuiz() {
        isReviewMode = false;
        score = 0;
        attempted = 0;
        currentIndex = 0;
        userAnswers = [];
        scoreMiniEl.textContent = "Score: 0";
        nextBtn.style.display = "inline-block";
        previousBtn.style.display = "inline-block";
        finishBtn.style.display = "inline-block";
        finishBtn.textContent = "Finish Quiz";
        finishBtn.onclick = () => {
            if (!questionsLoaded) return;
            if (confirm("Finish the quiz?")) {
                showFinalResult();
            }
            resetInactivityTimer();
        };
        finalScoreEl.style.display = "none";
        
        if (timerDuration > 0) {
            showTimerNotification();
            startTimer();
        }
        
        renderQuestion();
        resetInactivityTimer();
    }

    // ========== EVENT LISTENERS ==========
    loginFormEl.addEventListener("submit", async function(e) {
        e.preventDefault();
        
        if (isOnCooldown) {
            loginErrorEl.textContent = "Please wait for cooldown.";
            loginErrorEl.style.display = "block";
            return;
        }
        
        const username = usernameEl.value.trim();
        const password = passwordEl.value.trim();
        
        if (!username || !password) {
            loginErrorEl.textContent = "Enter username and password";
            loginErrorEl.style.display = "block";
            return;
        }
        
        loginErrorEl.textContent = "";
        loginErrorEl.style.display = "none";
        
        loginBtnEl.disabled = true;
        loginBtnEl.innerHTML = '‚è≥ Loading...';
        
        const loaded = await loadUsersFromGoogleSheet();
        
        if (!loaded || userList.length === 0) {
            loginErrorEl.textContent = "‚ö†Ô∏è Cannot load users. Check internet.";
            loginErrorEl.style.display = "block";
            loginBtnEl.disabled = false;
            loginBtnEl.innerHTML = 'üîí Login';
            return;
        }
        
        setTimeout(() => {
            const user = authenticateUser(username, password);
            
            if (user) {
                resetFailedAttempts();
                login(user);
            } else {
                recordFailedAttempt();
                
                if (failedAttempts >= MAX_ATTEMPTS) {
                    loginErrorEl.textContent = `Too many failed attempts. Wait ${COOLDOWN_TIME} seconds.`;
                } else {
                    loginErrorEl.textContent = `Invalid. ${MAX_ATTEMPTS - failedAttempts} attempt(s) left.`;
                }
                loginErrorEl.style.display = "block";
                usernameEl.focus();
            }
            
            loginBtnEl.disabled = false;
            loginBtnEl.innerHTML = 'üîí Login';
        }, 500);
    });

    passwordToggleEl.addEventListener("click", togglePasswordVisibility);
    headerLogoutBtnEl.addEventListener("click", logout);
    
    backToClassesBtn.addEventListener("click", () => {
        showClassSelection();
        resetInactivityTimer();
    });

    startBtnEl.addEventListener("click", () => {
        const chapterName = topicSelectEl.value;
        
        if (timerInterval) clearInterval(timerInterval);
        removeTimerNotification();
        
        loadQuestionsFromGoogleSheet(currentSubject, chapterName);
        resetInactivityTimer();
    });

    nextBtn.addEventListener("click", goToNextQuestion);
    previousBtn.addEventListener("click", goToPreviousQuestion);

    // ========== START APP ==========
    async function initializeApp() {
        await loadConfigurations();
        
        usernameEl.focus();
        console.log("üöÄ G. S. Tutorial App initialized");
        console.log("üìã Telegram:", TELEGRAM_CONFIG.ENABLED ? "Enabled" : "Disabled");
        console.log("üìã Admin Login Notifications:", ADMIN_CONFIG.NOTIFY_ON_LOGIN);
        console.log("üìã Admin Quiz Notifications:", ADMIN_CONFIG.NOTIFY_ON_QUIZ_RESULT);
        
        // FIX for Chrome extension error
        try {
            document.addEventListener('mousemove', resetInactivityTimer);
            document.addEventListener('keypress', resetInactivityTimer);
            document.addEventListener('click', resetInactivityTimer);
        } catch (error) {
            console.log("Note: Some event listeners may not be available in this context");
        }
        
        resetFailedAttempts();
    }

    // Use DOMContentLoaded but handle Chrome extension context
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeApp);
    } else {
        initializeApp();
    }
  </script>
  
  <script>
    // Service Worker with error handling for Chrome extension context
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("service-worker.js")
        .then(registration => {
          console.log("‚úÖ Service Worker registered");
        })
        .catch(error => {
          console.log("‚ö†Ô∏è Service Worker registration failed:", error);
        });
    }
  </script>
</body>
</html>
